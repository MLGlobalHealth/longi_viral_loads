# TODO: 
# Study transition matrices
# Axel:
# - could trajectories be generated by some latent transition matrices?
# - classify individuals as 3 possible types, each of which has an associated transition matrix
# - model populations proportions. 

# use dvl rather than dvl_15, to avoid discarding participant with few measurements.

################
# DEPENDENCIES #
################
library(data.table)
library(ggplot2)

################
#    PATHS     #
################

usr <- Sys.info()[['user']]
if(usr == 'andrea')
{
        init()
        indir.repository <-'~/git/longi_viral_loads'
}else{
        indir.repository <-'~/git/longi_viral_loads'
}

out.dir <- file.path(indir.repository,'results')
source(file.path(indir.repository, 'functions', 'preprocessing_helpers.R'))

cat('Loading `preprocessed_data.RData...`\n')
load(file.path(out.dir, 'preprocessed_data.RData'))
ls()
cat('Done`\n')


###########
# HELPERS #
###########

pairtype2binary <- function(x)
{
        x <- as.character(x)
        dict <- c('10', '00', '11', '01')
        names(dict ) <- c('newly_suppressed', 'durably_suppressed',
                          'persistently_viremic', 'viral_rebound')
        stopifnot(all(x %in% names(dict)))
        unname(dict[x])
}

`%^%` <- function(mat, pow)
{
        d = nrow(mat)
        stopifnot(d == ncol(mat))

        if(pow==0) return(diag(d))
        
        `%^%`(mat, pow-1) %*% mat
}

stationary <- function(transition) {
        stopifnot(is.matrix(transition) &&
                  nrow(transition)==ncol(transition) &&
                  all(transition>=0 & transition<=1))
        p <- diag(nrow(transition)) - transition
        A <- rbind(t(p),
                   rep(1, ncol(transition)))
        b <- c(rep(0, nrow(transition)),
               1)
        res <- qr.solve(A, b)
        names(res) <- paste0("state.", 1:nrow(transition))
        return(res)
}

########
# MAIN #
########

# Questions are:
# - can a mixture of simple transition matrix reproduce
#   the diversity in the observed VL trajectories? 

# At the moment I am excluding NA measurements...
dvisitpairs <- make_visit_pair(dvl)
dvisitpairs[, type2 := pairtype2binary(type)]
dvisitpairs

# Kate's classification of visit pairs + Markov Transitions

if(0)
{
# followup_viremic_suppressed_by_type(dvisitpairs_15)
followup_viremic_suppressed_by_type(dvisitpairs)
plot_visitpairs(dvisitpairs)
# dvisitpairs_16 <- make_visit_pair(dvl_16)

# Explore transition probabilities
dvisitpairs_15
dtransition <- dvisitpairs_15[,
                list(
                     study_id=study_id,
                     viremic_1 = hiv_vl > log10(THRESHOLD + 0.01) ,
                     viremic_2 = hiv_vl_2 > log10(THRESHOLD + 0.01) ,
                     round1 = gsub('-.*?$','',round),
                     round2 = gsub('^.*?-','',round)
                )] 
cols <- grep('viremic', names(dtransition), value=TRUE)
dtransition[, (cols):=lapply(.SD,as.integer) , .SDcols=cols]
dtransition


# initial proportions
dprob <- dtransition[, { z <- mean(viremic_2);
                 list(to0=1-z, to1=z)
                } , by=paste0('from', viremic_1)]
dprop_mat <- as.matrix(dprob[,-1 ])

a <- function(DT=dtransition, adj=FALSE)
{
        if(adj)
        {
                dprob <- DT[, { z <- mean(viremic_2);
                                 list(to0=1-z, to1=z)
                                } , by=paste0('from', viremic_1)]
                dprop_mat <- as.matrix(dprob[,-1 ])
                rownames(dprop_mat) <- c('from0', 'from1')
                print(knitr::kable(dprop_mat))
        }

        p1_viremic <- DT[, viremic_1[1], by='study_id'][, mean(V1)]
        p2_viremic <- DT[, viremic_2[1], by='study_id'][, mean(V1)]
        p3_viremic <- DT[, viremic_2[2], by='study_id'][, mean(V1)]
        p4_viremic <- DT[, viremic_2[3], by='study_id'][, mean(V1)]

        p_viremic <- c(p1_viremic, p2_viremic, p3_viremic, p4_viremic)


        # It seems like transitions from viremic to non-viremic status are 
        # well approximated by a Markov Process
        .f <- function(n){c(1-p1_viremic, p1_viremic) %*% (dprop_mat%^%(n-1))}

        tmp <- lapply(1:4, .f)
        tmp <- sapply(tmp, `[[`, 2)
        cat(' Proportion of viremic measurement at successive visits:\n',
            p_viremic,'\n',
            'Proportions estimated by the Markov Transition Matrix : \n',
            tmp, '\n'
        )

        out <- list(true=p_viremic, estimated=tmp)
        if(adj) out$matrix <- dprop_mat
        return(out)
}

# Does this hold when we look at specific groups too

dt2 <- merge(dtransition, dbirth[,.(study_id, sex)] )

cat('--- SEX == M ---')
aM <- a(DT=dt2[sex=='M'], adj=T)
cat('--- SEX == F ---')
aF <- a(DT=dt2[sex=='F'], adj=T)


stationary(aM$matrix)
}




# Want to code the GIBBS SAMPLER HERE:


gibbs.sampler.model <- function(data, N_t, priors, N_iter = 1000)
{
        # data is to be factored as number of times each type of transition direction has been observed.
        # N_t informs us one the needed parametes.

        # CHECK DATA
        # ----------
        if(ncol(data$S) != 4)
                stop('data$S should have 4 columns')
        data$I <- nrow(data$S)

        # CHECK PRIORS
        # ------------

        priors.names <- names(priors)

        if(! 'alpha' %in% priors.names )
        {
                if(! all(c('alpha00', 'alpha11') %in% priors.names))
                        stop('Either specify [alpha], or [alpha00,alpha11].')
        }else{
                if(any(c('alpha00', 'alpha11') %in% priors.names))
                        stop('Either specify [alpha], or [alpha00,alpha11], not both.')

                priors$alpha00 <- priors$alpha11 <- priors$alpha
        }

        if(is.null(priors$alpha00) | is.null(priors$alpha11))
                stop('Unspecified priors on alpha00 or alpha11')

        if(! 'p' %in% priors.names)
                priors$p <- rep(1, N_t)
        stopifnot(length(priors$p) == N_t)
        cat('Selected priors: \n\n')
        print(priors)
        cat('\n\n\n')

        # INITIALISE PARAMETERS
        # ---------------------

        # initialise samples
        tmp <- list(
                    pi00=rep(NA_real_, N_t), 
                    pi11=rep(NA_real_, N_t),
                    z = rep(NA_integer_, data$I )
        )
        samples <- lapply(1:(N_iter+1), function(i) tmp)

        if(1) 
        {
                samples[[1]]$pi00 <- rbeta(N_t, priors$alpha00, priors$alpha00)
                samples[[1]]$pi11 <- rbeta(N_t, priors$alpha11, priors$alpha11)
                samples[[1]]$z <- sample(1:N_t, data$I, replace=TRUE)
        }


        # START SAMPLER
        # -------------

        iter <- 2L
        while(iter <= N_iter + 1)
        {

                cat('Iter N:', iter - 1, ' out of ', N_iter,'\n')
                
                # update z_i
                T <- cbind(samples[[iter-1]]$pi00, 
                           1 - samples[[iter-1]]$pi00,
                           1 - samples[[iter-1]]$pi11,
                           samples[[iter-1]]$pi11) |> t()
                T.log <- log(T)

                p.log <- data$S %*% T.log
                p.log <- p.log + log(priors[['p']])
                p <- exp(p.log)
                p <- t(apply(p, 1, function(x){x/sum(x)}))
                
                samples[[iter]]$z <- sapply(1:data$I,
                                            function(i) sample(size=1, 1:N_t, prob = p[i,]) )

                # Given z, compute group S
                idx <- samples[[iter]]$z

                Sums_g <- lapply(1:N_t, 
                                 function(i){ colSums(data$S[idx == i,]) }
                )
                Sums_g <- do.call('rbind', Sums_g)

                # update pi00
                shapes <- Sums_g[, c(1,2)]
                shapes <- shapes + priors$alpha00
                samples[[iter]]$pi00 <- sapply(1:N_t,
                                               function(i)  rbeta(1, shapes[i, 1], shapes[i, 2]))

                # update pi11
                shapes <- Sums_g[, c(4,3)]
                shapes <- shapes + priors$alpha11
                samples[[iter]]$pi11 <- sapply(1:N_t,
                                               function(i)  rbeta(1, shapes[i, 1], shapes[i, 2]))

                iter <- iter + 1

        }

        return(samples)
}


# Transform visitpairs to S format
dvisitpairs <- make_visit_pair(dvl)
dvisitpairs[, type2 := pairtype2binary(type)]
S <- dvisitpairs[, .N, by=c('study_id', 'type2')]
S <- dcast(S, study_id ~ type2, value.var='N')
.f <- function(x){x[is.na(x)] <- 0; x}
S <- S[, lapply(.SD, .f) ]
S.idx2studyid <- S[, study_id]
cols <- setdiff(names(S), 'study_id')
S <- S[, .SD, .SDcols=cols]

gibbs_data <- list(S = as.matrix(S))
priors <- list(p=c(.3, .7), alpha=.8)

out <- gibbs.sampler.model(data=gibbs_data, N_t =2, priors=priors, N_iter=1000)
out

gibbs.summary <- function(samples)
{
        nms <- names(samples[[1]])
        
        rowstatistics <- function(mat)
        {
                out0 <- apply(mat, 2, quantile)
                out1 <- apply(mat, 2, mean)
                out <- rbind(out0, out1)
        }
        .f <- function(nm)
        {
                samples <- do.call('rbind', lapply(samples, `[[`, nm ))
                summ <- rowstatistics(samples)
                colnames(summ) <- paste0(nm, '_', 1:ncol(summ))
                summ
        }
        tmp <- lapply(nms, .f)
        tmp <- do.call('cbind', tmp)
        tmp <- t(tmp)
        tmp[grepl('^z', rownames(tmp)), 'out1'] <- tmp[grepl('^z', rownames(tmp)), 'out1'] - 1
        tmp[grepl('^z', rownames(tmp)), 'out1'] 
        tmp
}


plot_gibbs_iteration(samples, iter, dvisitpairs, S.idx2studyid)
{
        dict_iter <- function(iter){
                data.table(study_id = S.idx2studyid, 
                           z = samples[[iter]]$z )
        }
        dict <- dict_iter(iter)
        dvp <- dvisitpairs[, list(
                   hivdate=c(hivdate[1], hivdate_2),
                   hiv_vl=c(hiv_vl[1], hiv_vl_2)
        ), by=study_id]

        dvp <- merge(dvp, dict, by='study_id')

        idx <- dvp[z == 1, sample(unique(study_id), 100)]
        idx <- c(idx, dvp[z == 2, sample(unique(study_id), 100)])
        ggplot(dvp[study_id %in% idx],  aes(x=hivdate, y=hiv_vl, color=as.factor(z), group=study_id)) + 
                geom_path()

}

# Data should be a list containing all the info

# S should be a matrix with participants as rows, and with S00, S01, S10, S11 as columns



